import numpy as np
from PIL import Image
import os
import cv2
import re
import mimetypes
import hashlib
import io
import json
from datetime import datetime

# Try to import magic, but don't fail if it's not available
try:
    import magic
    MAGIC_AVAILABLE = True
except ImportError:
    MAGIC_AVAILABLE = False

# Try to import pefile, but don't fail if it's not available
try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

# Try to import yara, but don't fail if it's not available
try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False

class MalwareDetector:
    def __init__(self):
        self.known_malware_hashes = set()
        self.suspicious_patterns = {
            'executable': [
                b'MZ',  # DOS executable header
                b'PE\x00\x00',  # PE header
                b'This program cannot be run in DOS mode'  # DOS stub message
            ],
            'script': [
                b'<?php', b'<?=',  # PHP
                b'<script', b'javascript:',  # JavaScript
                b'powershell', b'cmd.exe',  # Shell commands
                b'exec(', b'eval(',  # Code execution
                b'base64_decode', b'from_base64'  # Encoding
            ],
            'network': [
                b'http://', b'https://', b'ftp://', b'ssh://',
                b'www.', b'.onion',  # URLs
                b'GET ', b'POST ', b'PUT ',  # HTTP methods
                b'User-Agent:', b'Cookie:',  # HTTP headers
            ],
            'suspicious': [
                b'CreateRemoteThread', b'VirtualAlloc', b'WriteProcessMemory',
                b'ShellExecute', b'WinExec', b'CreateProcess',
                b'LoadLibrary', b'GetProcAddress', b'SetWindowsHookEx',
                b'cmd.exe', b'powershell.exe', b'net.exe', b'wmic.exe'
            ]
        }
        
        # Initialize YARA rules if available
        if YARA_AVAILABLE:
            try:
                self.yara_rules = yara.compile(filepath='rules/malware.yar')
            except:
                self.yara_rules = None
        else:
            self.yara_rules = None
    
    def load_known_malware_hashes(self, hashes_file):
        """Load known malware hashes from file"""
        try:
            with open(hashes_file, 'r') as f:
                self.known_malware_hashes = set(line.strip() for line in f)
        except Exception as e:
            print(f"Error loading malware hashes: {e}")
    
    def extract_hidden_content(self, image_path):
        """Extract potential hidden content from steganographic image"""
        try:
            img = Image.open(image_path)
            # Convert image to bytes
            img_byte_arr = io.BytesIO()
            img.save(img_byte_arr, format=img.format)
            img_byte_arr = img_byte_arr.getvalue()
            
            # Extract LSB data
            binary_data = ''
            for byte in img_byte_arr:
                binary_data += format(byte, '08b')[-1]
            
            # Convert binary to bytes
            extracted_data = bytearray()
            for i in range(0, len(binary_data), 8):
                if i + 8 <= len(binary_data):
                    byte = int(binary_data[i:i+8], 2)
                    extracted_data.append(byte)
            
            return extracted_data
        except Exception as e:
            print(f"Error extracting hidden content: {e}")
            return None
    
    def analyze_extracted_content(self, content):
        """Analyze extracted content for malware indicators"""
        results = {
            'is_malware': False,
            'confidence': 0.0,
            'detection_methods': [],
            'threat_level': 'Low',
            'details': {}
        }
        
        if not content:
            return results
        
        # Calculate file hash
        file_hash = hashlib.sha256(content).hexdigest()
        
        # Check against known malware hashes
        if file_hash in self.known_malware_hashes:
            results['is_malware'] = True
            results['confidence'] = 1.0
            results['detection_methods'].append('Hash match')
            results['threat_level'] = 'High'
            results['details']['hash'] = file_hash
            return results
        
        # Try to determine file type from content
        # Save content to a temporary file to check its type
        temp_file = 'temp_analysis'
        try:
            with open(temp_file, 'wb') as f:
                f.write(content)
            file_type = mimetypes.guess_type(temp_file)[0] or 'unknown'
            results['details']['file_type'] = file_type
            os.remove(temp_file)
        except:
            results['details']['file_type'] = 'unknown'
        
        # Analyze PE files if pefile is available
        if PEFILE_AVAILABLE:
            try:
                pe = pefile.PE(data=content)
                # Check for suspicious characteristics
                if self._check_suspicious_pe(pe):
                    results['is_malware'] = True
                    results['confidence'] = 0.8
                    results['detection_methods'].append('PE analysis')
                    results['threat_level'] = 'Medium'
            except:
                pass
        
        # Check for suspicious patterns
        suspicious_patterns = self._check_suspicious_patterns(content)
        if suspicious_patterns:
            results['is_malware'] = True
            results['confidence'] = max(results['confidence'], 0.7)
            results['detection_methods'].append('Pattern analysis')
            results['threat_level'] = 'Medium'
            results['details']['suspicious_patterns'] = suspicious_patterns
        
        # Check for suspicious file types
        suspicious_types = [
            'application/x-executable',
            'application/x-dosexec',
            'application/x-msdos-program',
            'application/x-msdownload',
            'application/x-ms-wim',
            'application/x-ms-shortcut'
        ]
        
        if file_type in suspicious_types:
            results['is_malware'] = True
            results['confidence'] = max(results['confidence'], 0.6)
            results['detection_methods'].append('Suspicious file type')
            results['threat_level'] = 'Medium'
            results['details']['suspicious_type'] = file_type
        
        return results
    
    def _check_suspicious_pe(self, pe):
        """Check for suspicious characteristics in PE files"""
        if not PEFILE_AVAILABLE:
            return False
            
        suspicious = False
        
        # Check for suspicious imports
        suspicious_imports = [
            'VirtualAlloc', 'CreateRemoteThread', 'WriteProcessMemory',
            'ShellExecute', 'WinExec', 'CreateProcess', 'LoadLibrary',
            'GetProcAddress', 'CreateFile', 'WriteFile', 'ReadFile',
            'SetWindowsHookEx', 'SetThreadContext', 'ResumeThread'
        ]
        
        try:
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name and imp.name.decode() in suspicious_imports:
                        suspicious = True
                        break
        except:
            pass
        
        # Check for suspicious sections
        suspicious_section_names = ['.vmp', '.pack', '.upx', '.aspack', '.nspack', '.petite']
        for section in pe.sections:
            if section.Name.decode().strip('\x00') in suspicious_section_names:
                suspicious = True
                break
        
        return suspicious
    
    def _check_suspicious_patterns(self, content):
        """Check for suspicious patterns in the content"""
        patterns = []
        
        # Check for common malware strings
        malware_strings = [
            b'cmd.exe', b'powershell.exe', b'net.exe', b'wmic.exe',
            b'http://', b'https://', b'ftp://', b'ssh://',
            b'<script>', b'eval(', b'base64_decode', b'exec(',
            b'CreateRemoteThread', b'VirtualAlloc', b'WriteProcessMemory',
            b'ShellExecute', b'WinExec', b'CreateProcess',
            b'LoadLibrary', b'GetProcAddress', b'SetWindowsHookEx'
        ]
        
        for string in malware_strings:
            if string in content:
                patterns.append(string.decode())
        
        # Check for suspicious URLs
        url_pattern = re.compile(b'https?://[^\\s<>"]+|www\\.[^\\s<>"]+')
        urls = url_pattern.findall(content)
        if urls:
            patterns.extend([url.decode() for url in urls])
        
        # Check for base64 encoded content
        base64_pattern = re.compile(b'[A-Za-z0-9+/]{50,}={0,2}')
        base64_matches = base64_pattern.findall(content)
        if base64_matches:
            patterns.extend(['Base64 encoded content'])
        
        return patterns
    
    def analyze_image(self, image_path):
        """Analyze the image itself for suspicious patterns"""
        try:
            img = Image.open(image_path)
            img_array = np.array(img)
            
            # Check for unusual image characteristics
            results = {
                'unusual_size': False,
                'unusual_format': False,
                'unusual_entropy': False,
                'suspicious_pixels': False
            }
            
            # Check image size
            if img.size[0] > 10000 or img.size[1] > 10000:
                results['unusual_size'] = True
            
            # Check image format
            if img.format not in ['PNG', 'JPEG', 'BMP', 'GIF']:
                results['unusual_format'] = True
            
            # Calculate image entropy
            entropy = self._calculate_entropy(img_array)
            if entropy > 7.5:  # High entropy might indicate hidden data
                results['unusual_entropy'] = True
            
            # Check for suspicious pixel patterns
            if self._check_suspicious_pixels(img_array):
                results['suspicious_pixels'] = True
            
            return results
        except Exception as e:
            print(f"Error analyzing image: {e}")
            return None
    
    def _calculate_entropy(self, img_array):
        """Calculate image entropy"""
        hist = cv2.calcHist([img_array], [0], None, [256], [0, 256])
        hist = hist.ravel() / hist.sum()
        entropy = -np.sum(hist * np.log2(hist + 1e-7))
        return entropy
    
    def _check_suspicious_pixels(self, img_array):
        """Check for suspicious pixel patterns that might indicate hidden data"""
        # Check for LSB patterns
        lsb_pattern = img_array & 1
        if np.sum(lsb_pattern) > 0.5 * lsb_pattern.size:
            return True
        
        # Check for unusual color distributions
        color_std = np.std(img_array, axis=(0, 1))
        if np.any(color_std > 100):  # High standard deviation might indicate hidden data
            return True
        
        return False
    
    def detect_malware(self, image_path):
        """Main method to detect malware in image and its content"""
        results = {
            'is_malware': False,
            'confidence': 0.0,
            'detection_methods': [],
            'threat_level': 'Low',
            'details': {},
            'timestamp': datetime.now().isoformat()
        }
        
        # 1. Analyze the image itself
        image_analysis = self.analyze_image(image_path)
        if image_analysis:
            suspicious_factors = sum(image_analysis.values())
            if suspicious_factors > 0:
                results['confidence'] += 0.2 * suspicious_factors
                results['detection_methods'].append('Image analysis')
                results['details']['image_analysis'] = image_analysis
        
        # 2. Extract and analyze hidden content
        hidden_content = self.extract_hidden_content(image_path)
        if hidden_content:
            content_analysis = self.analyze_extracted_content(hidden_content)
            if content_analysis['is_malware']:
                results['is_malware'] = True
                results['confidence'] = max(results['confidence'], content_analysis['confidence'])
                results['detection_methods'].extend(content_analysis['detection_methods'])
                results['details'].update(content_analysis['details'])
        
        # 3. Check file metadata
        try:
            if MAGIC_AVAILABLE:
                file_type = magic.from_file(image_path, mime=True)
            else:
                file_type = mimetypes.guess_type(image_path)[0] or 'unknown'
                
            if file_type in ['application/x-executable', 'application/x-dosexec']:
                results['is_malware'] = True
                results['confidence'] = max(results['confidence'], 0.8)
                results['detection_methods'].append('Executable file type')
                results['details']['file_type'] = file_type
        except:
            pass
        
        # 4. Apply YARA rules if available
        if YARA_AVAILABLE and self.yara_rules:
            try:
                matches = self.yara_rules.match(image_path)
                if matches:
                    results['is_malware'] = True
                    results['confidence'] = max(results['confidence'], 0.9)
                    results['detection_methods'].append('YARA rule match')
                    results['details']['yara_matches'] = [str(match) for match in matches]
            except:
                pass
        
        # Determine threat level based on confidence
        if results['confidence'] >= 0.8:
            results['threat_level'] = 'High'
        elif results['confidence'] >= 0.5:
            results['threat_level'] = 'Medium'
        
        return results 